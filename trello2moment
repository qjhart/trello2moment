#! /usr/bin/env node
'use strict';

const yargs=require('yargs');
const jf=require('jsonfile');
const fs=require('fs');
const path=require('path');
const N3=require('n3');
const { namedNode, literal, defaultGraph, quad } = N3.DataFactory;
const n3u=N3.Util;
const marked = require('marked');
const traverse = require('traverse');

var prefix= {
  schema: 'http://schema.org/',
  ucdlib: 'http://digital.ucdavis.edu/schema#',
	w: 'http://library.ucdavis.edu/wine-ontology#',
  fast: 'http://id.worldcat.org/fast/',
	wdt: 'http://www.wikidata.org/prop/direct/',
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'
}

var rdf= {
  type:1
}
Object.keys(rdf).forEach((k)=>{rdf[k]=namedNode(prefix.rdf+k)});

var schema = {
  CreativeWork:1,
  Person:1,
  Place:1,
  VisualArtwork:1,
  WebPage:1,
  Event:1,
  Thing:1,
  description:1,
  license:1,
  relatedLink:1,
  name:1,
  publisher:1,
  significantLinks:1,
  spatial:1,
  temporal:1,
  thumbnail:1,
}
Object.keys(schema).forEach((k)=>{schema[k]=namedNode(prefix.schema+k)});

function moment (board_name) {
	let errl=[];
	let warnl=[];
	let writer=new N3.Writer({prefixes: prefix});
  let card_type={};

	function add(s,p,o) {
		return writer.addQuad(s,p,o);
	}

  // This function associates the trello column name with a schema type.
  // The schema type is used as the <> a schema:Foo part.
  // Connections => schema:significantLinks.
  function set_card_type_from_lists(lists) {
    lists.forEach((l)=>{
      let m = l.name;
      if (m==='Connections') {
        m='significantLinks';
      }
      if (m==='Object')
        m='Thing';

      if (m!=='Card Creation Guides') {
        if (m && schema[m]) {
          console.error(`schema[${m}]`);
          card_type[l.id]=schema[m];
        } else {
          console.error(`namedNode(${prefix.ucdlib}${m})`);
          card_type[l.id]=namedNode(prefix.ucdlib+m.replace(/\s+/g,'_'));
        }
      }
    });
  }

  function add_desc(node,desc) {

    // This version of add will do some additional testing for adding literals.etc
    function add_spo(s,p,o) {

      const urlre=/^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/;

      if(typeof(o)==='string')
        o=o.replace(/[\s\n]+$/,'');
      console.error(`add_desc.add_spo{"${s.id}","${p}","${o}"}`);

      let predicates={
        'when':schema.temporal,
        'description':schema.description,
        'links to learn more':schema.relatedLink,
        'location':schema.spatial
      };

      if (typeof(p)==='string') {
        p.replace(/[\s\n]+$/,'');
        p=predicates[p.toLowerCase()];
      }
      if (typeof(s)==='string') {
        if (s.match(urlre)) {
          s=namedNode(s.replace('https://trello.com/c/','#'));
        }
      }

      if (p && o) {
        if (typeof(o)==='string') {
          if (o.match(urlre)) {
            o=namedNode(o.replace('https://trello.com/c/','#'));
            console.error(`{<${s.id}>,<${p.id}>,<${o}>}`);
          }
          else {
            o=literal(o)
            console.error(`{<${s.id}>,<${p.id}>,"${o}"}`);
          }
        }
        add(s,p,o);
      }
    }

    let pred='';
    let text=[''];
    let list_depth=0;

    let json = marked.lexer(desc);
    // Silly way to flush
    json.push({type:'heading','text':'EndQ'});

    json.forEach((item)=>{
      //console.error(item);
      switch (item.type) {
      case 'heading':
        add_spo(node,pred,text[0]);
        pred=item.text;
        list_depth=0;
        text=[''];
        break;
      case 'list_start':
        list_depth++;
        text[list_depth]='';
        //console.error(`list_depth=${list_depth}`);
        break;
      case 'list_end':
        list_depth--;
        //console.error(`list_depth=${list_depth}`);
        break;
      case 'list_item_start':
        break;
      case 'list_item_end':
        switch(pred) {
        case "Location":
          if (list_depth===1) {
            add_spo(node,pred,text[list_depth]);
          }
          break;
        case "When":
          if (list_depth===1) {
            add_spo(node,pred,text[list_depth]);
          }
          break;
        case "Links to Learn More":
          if (list_depth===2) {
            add_spo(node,pred,text[list_depth]);
          }
          break
        default:
          console.error(`# ${node},${pred} ${text[1]} #`);
        }
        text[list_depth]='';
        break;
      case 'text':
        text[list_depth] += item.text;
        break;
      case 'space':
        text[list_depth] += ' ';
        break;
      case 'paragraph':
        text[list_depth] += item.text;
        break;
      default:
        break;
      }
    });
  }


  function add_card(card) {
    let type=card_type[card.idList];
//    let attachment_re=new RegExp('https://trello.com/c/(^[/]*)/.*$');
    let attachment_re=new RegExp('https://trello.com/c/(.*)/.*$');
    if (type) {
      let n=namedNode('#'+card.shortLink);
      add(n,schema.name,literal(card.name));
	    add(n,schema.publisher,namedNode('http://id.loc.gov/authorities/names/no2008108707'));
      add(n,schema.license,namedNode('http://rightsstatements.org/vocab/CNE/1.0/'));
      add(n,rdf.type,type);
      if (card.idAttachmentCover) {
        console.error('card.cover');
        card.attachments.forEach((a)=>{
          if (a.id === card.idAttachmentCover) {
            console.error('card.cover.add');
            add(n,schema.thumbnail,namedNode(path.join(card.shortLink,path.basename(a.url))));
          }
        });
      }
      if (type===schema.significantLinks) {
        // Now get the labels to use
        card.labels.forEach((l)=>{
          let to_from=l.name.split(" / ");
          if (to_from.length === 2) {
            let sub=namedNode(card.attachments[1].url.replace(attachment_re,`#$1`));
            let obj=namedNode(card.attachments[0].url.replace(attachment_re,`#$1`));

            // Create a unique predicate of type significant Links
            // At a later date, we can add rules to create the reversal
            let pred=n;
            if ("desc" in card) {
              add(n,schema.description,literal(card.desc));
            }

            let pred_type=namedNode(prefix.ucdlib+to_from[0].replace(/\s+/g,'_'));
            console.error(`add(${pred.id},rdf.type,schema.significantLinks)`);
            console.error(`add(${pred.id},rdf.type,${pred_type.id})`);
            console.error(`add(${pred.id},schema.name,${to_from[0]})`);
            console.error(`add(${sub},${pred.id},${obj})`);
            // add(pred,rdf.type,schema.significantLinks);
            add(pred,rdf.type,pred_type);
            add(pred,schema.name,literal(to_from[0]));
            add(sub,pred,obj);
            // At a Later Date, we can add in rules for reverse predicates so
            // this wouldn't be necessary
            let rev_pred=namedNode(n.id+'_rev');
            let rev_pred_type=namedNode(prefix.ucdlib+to_from[1].replace(/\s+/g,'_'));
            console.error(`add(${rev_pred.id},rdf.type,schema.significantLinks)`);
            console.error(`add(${rev_pred.id},rdf.type,${rev_pred_type.id})`);
            console.error(`add(${rev_pred.id},schema.name,${to_from[0]})`);
            console.error(`add(${sub},${rev_pred.id},${obj})`);
            add(rev_pred,rdf.type,schema.significantLinks);
            add(rev_pred,rdf.type,rev_pred_type);
            add(rev_pred,schema.name,literal(to_from[1]));
            add(obj,rev_pred,sub);
          }
        });
      } else {
        add(n,rdf.type,schema.WebPage);
        if ("desc" in card)
          add_desc(n,card.desc);
      }
    }
  }

  let board;
  // Get json filename
  let board_fn=path.join(board_name,'board.json')

  try {
		board=jf.readFileSync(board_fn)
	} catch (err) {
		warnl.push(`${board_fn} not found`);
	}

  set_card_type_from_lists(board.lists);
  let cards=board.cards;

  cards.forEach((k)=>add_card(k));

  writer.end(function (error, result) { console.log(result); });

  if (true) {
	  if ( errl.length>0 || warnl.length>0) {
		  console.error([cardfile,errl.join(' '),warnl.join(' ')].join(':'));
	  }
  }
}

let argv=yargs.usage('trello2moment --board=[Short URL]').
    demandOption(['board']).argv;
moment(argv.board);
