#! /usr/bin/env node
'use strict';

const yargs=require('yargs');
const jf=require('jsonfile');
const fs=require('fs');
const path=require('path');
const N3=require('n3');
const { namedNode, literal, defaultGraph, quad } = N3.DataFactory;
const n3u=N3.Util;
const marked = require('marked');
const traverse = require('traverse');

var prefix= {
  schema: 'http://schema.org/',
  ucdlib: 'http://digital.ucdavis.edu/schema#',
	w: 'http://library.ucdavis.edu/wine-ontology#',
  fast: 'http://id.worldcat.org/fast/',
	wdt: 'http://www.wikidata.org/prop/direct/',
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#'
}

var rdf= {
  type:1
}
Object.keys(rdf).forEach((k)=>{rdf[k]=namedNode(prefix.rdf+k)});

var schema = {
  CreativeWork:1,
  Person:1,
  Place:1,
  VisualArtwork:1,
  WebPage:1,
  description:1,
  license:1,
  relatedLink:1,
  name:1,
  publisher:1,
  significantLinks:1,
  spatial:1,
  temporal:1
}
Object.keys(schema).forEach((k)=>{schema[k]=namedNode(prefix.schema+k)});

function moment (board) {
	let errl=[];
	let warnl=[];
  let cards;
	let writer=new N3.Writer({prefixes: prefix});

	function add(s,p,o) {
		return writer.addQuad(s,p,o);
	}

  function list_types() {
    let lists = [];
    let type={};
    try {
		  lists=jf.readFileSync(path.join(board,'lists.json'));
	  } catch (err) {
		  warnl.push(path.join(board,'lists.json')+` not found`);
	  }
    lists.forEach((l)=>{
      let m = l.name.match(/\((.*)\)/);
      if (m && m[1] && schema[m[1]]) {
        type[l.id]=schema[m[1]];
      } else {
        type[l.id]=namedNode(prefix.ucdlib+l.name.replace(/\s+/g,'_'));
      }
    });
    return type;
  }

  function add_desc(node,desc) {

    const urlre=/^(http:\/\/www\.|https:\/\/www\.|http:\/\/|https:\/\/)?[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$/;

    function add_spo(s,p,o) {
      if(typeof(o)==='string')
        o=o.replace(/[\s\n]+$/,'');
      console.error(`add_desc.add_spo{"${s.id}","${p}","${o}"}`);

      let predicates={
        'when':schema.temporal,
        'description':schema.description,
        'links to learn more':schema.relatedLink,
        'location':schema.spatial
      };
      if (typeof(p)==='string') {
        p.replace(/[\s\n]+$/,'');
        p=predicates[p.toLowerCase()];
      }
      if (typeof(s)==='string') {
        if (s.match(urlre)) {
          s=namedNode(s.replace('https://trello.com/c/','#'));
        }
      }

      if (p && o) {
        if (typeof(o)==='string') {
          if (o.match(urlre)) {
            o=namedNode(o.replace('https://trello.com/c/','#'));
            console.error(`{<${s.id}>,<${p.id}>,<${o}>}`);
          }
          else {
            o=literal(o)
            console.error(`{<${s.id}>,<${p.id}>,"${o}"}`);
          }
        }
        add(s,p,o);
      }
    }

    let in_connection=false;

    let pred='';
    let text=[''];
    let link=null;
    let link_count=1;
    let list_depth=0;

    let json = marked.lexer(desc);
    // Silly way to flush
    json.push({type:'heading','text':'EndQ'});

    json.forEach((item)=>{
      //console.error(item);
      switch (item.type) {
      case 'heading':
        if (item.text.toLowerCase() === 'connections') {
          in_connection=true;
          //console.error('in_connection');
        } else {
          if(! in_connection && text[0]) {
            add_spo(node,pred,text[0]);
          }
          in_connection=false;
          link=null;
          pred=item.text;
        }
        list_depth=0;
        text=[''];
        break;
      case 'list_start':
        list_depth++;
        text[list_depth]='';
        //console.error(`list_depth=${list_depth}`);
        break;
      case 'list_end':
        list_depth--;
        //console.error(`list_depth=${list_depth}`);
        break;
      case 'list_item_start':
        break;
      case 'list_item_end':
        // List act differently in connections header
        if (in_connection) {
          if (list_depth === 2 && link && link.node && text[2]) {
            console.error(`add_spo(${link.node},${schema.description},${text[2]})`);
            add_spo(link.node,schema.description,text[2]);
          } else if (list_depth === 1) {
            // split text, get url
            text[1]=text[1].replace(/[\s\n]+$/,'');
            let t=text[1].split(" ");
            link={
              node:namedNode(node.id.replace('https://trello.com/c/','#')+'_'+link_count++),
            };
            add_spo(link.node,rdf.type,schema.significantLinks);

            link.object=t.pop();
            link.predicate=t.pop();

            // Forward link => predicate is name, object is URL
            if (link.object.match(urlre)) {
              console.error(`add_spo(${link.node.id},${schema.name.id},"${link.predicate}")`);
              add_spo(link.node,schema.name,link.predicate);
              console.error(`add_spo(${node.id},${link.node.id},${link.object})`);
              add_spo(node,link.node,link.object);
            } else if (link.predicate.match(urlre)) { // Reverse Links Predicate is URL
              console.error(`add_spo(${link.node.id},${schema.name.id},"${link.object}")`);
              add_spo(link.node,schema.name,link.object);
              console.error(`add_spo(${link.predicate},${link.node.id},${node.id})`);
              add_spo(link.predicate,link.node,node);
            } else {
              console.error(`BAD(${link.node.id},${link.predicate},${link.object})`);
            }
            text[1]='';
          }
        } else {
          switch(pred) {
          case "Location":
            if (list_depth===1) {
              add_spo(node,pred,text[list_depth]);
            }
            break;
          case "When":
            if (list_depth===1) {
              add_spo(node,pred,text[list_depth]);
            }
            break;
          case "Links to Learn More":
            if (list_depth===2) {
              add_spo(node,pred,text[list_depth]);
            }
            break
          default:
            console.error(`# ${node},${pred} ${text[1]} #`);
          }
          text[list_depth]='';
        }
        break;
      case 'text':
        text[list_depth] += item.text;
        break;
      case 'space':
        text[list_depth] += ' ';
        break;
      case 'paragraph':
        text[list_depth] += item.text;
        break;
      default:
        break;
      }
    });
  }

  function add_card(card) {
    let n=namedNode('#'+card.shortLink);
    add(n,rdf.type,schema.WebPage);
    if (types[card.idList])
      add(n,rdf.type,types[card.idList]);

    add(n,schema.name,literal(card.name));
	  add(n,schema.publisher,namedNode('http://id.loc.gov/authorities/names/no2008108707'));
    add(n,schema.license,namedNode('http://rightsstatements.org/vocab/CNE/1.0/'));
    console.error(`SHORTLINK: ${card.shortUrl}`);
    if ("desc" in card)
      add_desc(n,card.desc);
  }

  let types=list_types(board);

	try {
		cards=jf.readFileSync(path.join(board,'cards.json'));
	} catch (err) {
		warnl.push(path.join(board,'cards.json')+` not found`);
	}

  cards.forEach((k)=>add_card(k));

  writer.end(function (error, result) { console.log(result); });

  if (true) {
	  if ( errl.length>0 || warnl.length>0) {
		  console.error([cardfile,errl.join(' '),warnl.join(' ')].join(':'));
	  }
  }
}

let argv=yargs.usage('trello2moment --board=[Short URL]').
    demandOption(['board']).argv;
moment(argv.board);
